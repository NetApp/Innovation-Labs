import{_ as t,c as i,o as a,ag as r}from"./chunks/framework.By5zrZ8k.js";const h=JSON.parse('{"title":"Document-Based RAG with NetApp","description":"","frontmatter":{},"headers":[],"relativePath":"projects/document-rag/README.md","filePath":"projects/document-rag/README.md","lastUpdated":1768528464000}'),n={name:"projects/document-rag/README.md"};function o(s,e,l,c,p,d){return a(),i("div",null,[...e[0]||(e[0]=[r('<h1 id="document-based-rag-with-netapp" tabindex="-1">Document-Based RAG with NetApp <a class="header-anchor" href="#document-based-rag-with-netapp" aria-label="Permalink to &quot;Document-Based RAG with NetApp&quot;">â€‹</a></h1><h2 id="_1-introduction" tabindex="-1">1. Introduction <a class="header-anchor" href="#_1-introduction" aria-label="Permalink to &quot;1. Introduction&quot;">â€‹</a></h2><p>This project captures a <strong>Document-centric Retrieval-Augmented Generation (RAG)</strong> architecture developed and validated by <strong>NetApp</strong>.</p><p>The focus is on building RAG systems that are <strong>explainable, deterministic, and governance-ready</strong> from day one. Instead of defaulting to vector-only retrieval, this architecture uses <strong>BM25 lexical search</strong>, enriched with <strong>explicit entity extraction</strong>, to make every retrieval decision observable and reproducible.</p><p>The complete reference implementation, including open source code and step-by-step guides, lives here: ðŸ‘‰ <strong><a href="https://github.com/NetApp/document-rag-guide" target="_blank" rel="noreferrer">https://github.com/NetApp/document-rag-guide</a></strong></p><p>This page serves as the <strong>NetApp-specific overview and entry point</strong>.</p><h2 id="_2-why-document-rag" tabindex="-1">2. Why Document RAG <a class="header-anchor" href="#_2-why-document-rag" aria-label="Permalink to &quot;2. Why Document RAG&quot;">â€‹</a></h2><p>Most RAG stacks begin with embeddings and end with uncomfortable questions:</p><ul><li>Why did this document match?</li><li>Which terms mattered?</li><li>Can we reproduce this result tomorrow?</li><li>Can we prove compliance?</li></ul><p>Document-based RAG flips that model.</p><p><img src="https://raw.githubusercontent.com/NetApp/document-rag-guide/refs/heads/main/images/enterprise_deployment.png" alt="Document RAG with Reinforcement Learning"></p><p>Instead of treating retrieval as an opaque side effect of embeddings, it treats retrieval as a <strong>first-class, auditable system</strong>.</p><p>Key reasons this approach works:</p><ul><li><p><strong>Explainability by default</strong>: BM25 matches explicit fields and terms. You can point to the exact reason a document was retrieved.</p></li><li><p><strong>Deterministic behavior</strong>: The same query over the same data produces the same result. No hidden ranking drift.</p></li><li><p><strong>Reduced hallucinations</strong>: LLM responses are grounded in retrieved documents, not semantic &quot;near matches.&quot;</p></li><li><p><strong>Clear governance boundaries</strong>: Explicit document metadata, entity fields, and retention policies make audits practical instead of theoretical.</p></li></ul><p>Vectors still exist, but only as <strong>augmentation</strong>, never as the sole authority.</p><h2 id="_3-how-netapp-enhances-this-architecture" tabindex="-1">3. How NetApp Enhances This Architecture <a class="header-anchor" href="#_3-how-netapp-enhances-this-architecture" aria-label="Permalink to &quot;3. How NetApp Enhances This Architecture&quot;">â€‹</a></h2><p>NetApp extends Document RAG with <strong>enterprise-grade data management and storage capabilities</strong> that turn a clean design into a deployable system.</p><p>Key NetApp-specific enhancements include:</p><ul><li><p><strong>Dual-tier memory model</strong></p><ul><li><strong>Long-Term (LT)</strong>: authoritative, durable document store</li><li><strong>HOT (unstable)</strong>: short-lived, user- or session-specific working set</li></ul></li><li><p><strong>Governance-driven isolation</strong></p><ul><li>HOT exists to enforce retention, policy asymmetry, and blast-radius control</li><li>LT remains stable, conservative, and audit-ready</li></ul></li><li><p><strong>High-performance locality</strong></p><ul><li>NetApp FlexCache keeps frequently accessed documents close to compute</li><li>Cache eviction is explicit and policy-driven, not accidental</li></ul></li><li><p><strong>Enterprise resilience</strong></p><ul><li>SnapMirror and MetroCluster support replication and disaster recovery</li><li>Snapshots enable point-in-time audits of &quot;what the AI knew&quot;</li></ul></li><li><p><strong>Safe experimentation</strong></p><ul><li>FlexClone enables instant copies of indices for testing new analyzers or embeddings without impacting production</li></ul></li></ul><p>The result is a Document RAG architecture that aligns with how enterprises already manage data: <strong>explicit, observable, and controlled</strong>.</p><h2 id="_4-visit-the-github-project-for-more-details" tabindex="-1">4. Visit the GitHub Project for More Details <a class="header-anchor" href="#_4-visit-the-github-project-for-more-details" aria-label="Permalink to &quot;4. Visit the GitHub Project for More Details&quot;">â€‹</a></h2><p>This page is intentionally high-level.</p><p>For full technical details, code, and deployment guidance, visit the main project:</p><p>ðŸ‘‰ <strong><a href="https://github.com/NetApp/document-rag-guide" target="_blank" rel="noreferrer">https://github.com/NetApp/document-rag-guide</a></strong></p><p>There you&#39;ll find:</p><ul><li>A fully open source, community-runnable implementation</li><li>An enterprise architecture with HOT/LT separation and promotion workflows</li><li>Clear patterns for explainable, compliant retrieval</li></ul><p>If your goal is AI you can <strong>explain, reproduce, and defend</strong>, start there.</p>',27)])])}const g=t(n,[["render",o]]);export{h as __pageData,g as default};
