import{_ as t,c as a,o as r,ag as i}from"./chunks/framework.By5zrZ8k.js";const g=JSON.parse('{"title":"Graph RAG with NetApp","description":"","frontmatter":{},"headers":[],"relativePath":"projects/graph-rag/README.md","filePath":"projects/graph-rag/README.md","lastUpdated":1768528464000}'),n={name:"projects/graph-rag/README.md"};function o(s,e,l,p,h,d){return r(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="graph-rag-with-netapp" tabindex="-1">Graph RAG with NetApp <a class="header-anchor" href="#graph-rag-with-netapp" aria-label="Permalink to &quot;Graph RAG with NetApp&quot;">â€‹</a></h1><h2 id="_1-introduction" tabindex="-1">1. Introduction <a class="header-anchor" href="#_1-introduction" aria-label="Permalink to &quot;1. Introduction&quot;">â€‹</a></h2><p>This project documents a <strong>Graph-based Retrieval-Augmented Generation (Graph RAG)</strong> architecture developed and tested by <strong>NetApp</strong>.</p><p>The goal is simple: show how enterprises can build AI systems that are <strong>explainable, governable, and production-ready</strong>, not just clever demos. Instead of relying only on vector embeddings, this architecture uses <strong>knowledge graphs with explicit relationships</strong>, combined with a dual-memory model that separates authoritative knowledge from fast, conversational context.</p><p>The full reference implementation, including open source code and detailed walkthroughs, lives here: ðŸ‘‰ <strong><a href="https://github.com/NetApp/graph-rag-guide" target="_blank" rel="noreferrer">https://github.com/NetApp/graph-rag-guide</a></strong></p><p>This repository serves as the <strong>NetApp-focused entry point</strong> and architectural overview.</p><h2 id="_2-why-graph-rag" tabindex="-1">2. Why Graph RAG <a class="header-anchor" href="#_2-why-graph-rag" aria-label="Permalink to &quot;2. Why Graph RAG&quot;">â€‹</a></h2><p><img src="https://raw.githubusercontent.com/NetApp/graph-rag-guide/refs/heads/main/images/rag-graph.png" alt="Graph RAG"></p><p>Traditional RAG pipelines usually start and end with vector search. That works for similarity matching, but it breaks down when teams need:</p><ul><li>Clear explanations for why an answer was returned</li><li>Auditable data lineage and provenance</li><li>Multi-hop reasoning across related facts</li><li>Strong governance and compliance controls</li></ul><p>Graph RAG addresses these gaps by storing knowledge as <strong>nodes and relationships</strong> instead of opaque embeddings.</p><p>Key advantages include:</p><ul><li><p><strong>Reduced hallucinations</strong>: Responses are grounded in explicit graph paths, not nearest-neighbor guesses.</p></li><li><p><strong>Explainability by design</strong>: Every answer can be traced through readable graph queries.</p></li><li><p><strong>Better governance</strong>: Provenance, confidence, and promotion logic live directly in the data model.</p></li><li><p><strong>Multi-step reasoning</strong>: Graphs naturally support traversals across documents, entities, and concepts.</p></li></ul><p>This architecture treats retrieval as a <strong>first-class system</strong>, not a side effect of embeddings.</p><h2 id="_3-how-netapp-enhances-this-architecture" tabindex="-1">3. How NetApp Enhances This Architecture <a class="header-anchor" href="#_3-how-netapp-enhances-this-architecture" aria-label="Permalink to &quot;3. How NetApp Enhances This Architecture&quot;">â€‹</a></h2><p>NetApp extends the core Graph RAG design with <strong>enterprise-grade data and storage capabilities</strong> that make it practical at scale.</p><p>Key enhancements include:</p><ul><li><p><strong>Dual-memory architecture</strong></p><ul><li>Long-term memory for authoritative, durable knowledge</li><li>Short-term memory for fast, conversational context</li></ul></li><li><p><strong>High-performance caching</strong></p><ul><li>NetApp FlexCache enables microsecond-level access to hot graph data</li><li>Cached data expires automatically to prevent stale knowledge</li></ul></li><li><p><strong>Data mobility and resilience</strong></p><ul><li>SnapMirror provides replication and recovery across sites</li><li>Storage follows workloads, not the other way around</li></ul></li><li><p><strong>Promotion and reinforcement workflows</strong></p><ul><li>Frequently used or validated facts are promoted from cache to long-term memory</li><li>Confidence, provenance, and audit metadata are preserved end-to-end</li></ul></li><li><p><strong>Operational readiness</strong></p><ul><li>Designed to integrate with streaming pipelines and production infrastructure</li><li>Supports regulated environments where traceability is non-negotiable</li></ul></li></ul><p>The result is a Graph RAG architecture that aligns with real enterprise constraints: performance, governance, and scale.</p><h2 id="_4-visit-the-github-project-for-more-details" tabindex="-1">4. Visit the GitHub Project for More Details <a class="header-anchor" href="#_4-visit-the-github-project-for-more-details" aria-label="Permalink to &quot;4. Visit the GitHub Project for More Details&quot;">â€‹</a></h2><p>This page is only a summary.</p><p>For full architecture diagrams, implementation details, and runnable examples, visit the main project:</p><p>ðŸ‘‰ <strong><a href="https://github.com/NetApp/graph-rag-guide" target="_blank" rel="noreferrer">https://github.com/NetApp/graph-rag-guide</a></strong></p><p>There you&#39;ll find:</p><ul><li>A community, open source reference implementation</li><li>An enterprise-grade architecture with promotion and governance patterns</li><li>Clear upgrade paths from laptop demos to production deployments</li></ul><p>If you&#39;re building AI systems that need to be trusted, explained, and operated long-term, start there.</p>',26)])])}const u=t(n,[["render",o]]);export{g as __pageData,u as default};
